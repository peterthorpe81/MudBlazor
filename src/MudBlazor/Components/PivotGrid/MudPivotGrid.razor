@namespace MudBlazor
@inherits MudComponentBase
@using MudBlazor.Pivot
@using MudBlazor.Utilities
@typeparam T
@inject InternalMudLocalizer Localizer

<div @attributes="UserAttributes" class="@_classname" style="@_style">
    @if (Items is not null && Columns is not null && Rows is not null && Measures is not null &&
        Items.Any() && Measures.Any())
    {

        <div class="@_tableClass" style="@_tableStyle">
        <table class="mud-table-root" data-hRows="@ColHeaderRowCount" data-hCols="@RowHeaderColCount">

            @*Render Headers*@
            @{
                var cornerRows = ColHeaderRowCount - (RenderHeaderTitles ? 1 : 0);
                var cornerColumns = RowHeaderColCount - (RenderHeaderTitles ? 1 : 0);
                    <thead class="@_headClassname">
                    @for (var i = 0; i < RowRender.MaxDepth; i++)
                    {
                        <tr class="@_headRowClassname">
                            @if (i == 0)
                            {
                                <th class="@_cornerClass" colspan="@cornerColumns" rowspan="@cornerRows"></th>
                            }
                            @if (IsVertical && RenderHeaderTitles && i + 1 == RowRender.MaxDepth)
                            {
                               @for (int j = 0; j < ColRender.MaxDepth; j++)
                                    {
                                        var inverseDepth = ColRender.MaxDepth - j;
                                        <th class="@_rowTitleClass dpth-@inverseDepth tmph">@ColRender.HeaderTitle(j)</th>
                                    }
                            }
                            @if (RenderHeaderTitles)
                            {
                                var inverseDepth = RowRender.MaxDepth - i;
                                var _columnTitleClass = new CssBuilder("mud-pivot-column-title").AddClass("mud-table-cell").AddClass($"dpth-{inverseDepth}").Build();
                                <th class="@_columnTitleClass tmps @i @RowRender.MaxDepth">@RowRender.HeaderTitle(i)</th>
                            }
                            @foreach (var cell in RowRender[i])
                            {
                                var leafCount = cell.Leaf.Count() * HorisontalMeasureRatio;
                                var isTotal = (cell is PivotTableTotalColumnRender<T>);
                                var rowSpan = (isTotal ? RowRender.MaxDepth - cell.depth : 1);
                                var inverseDepth = RowRender.MaxDepth - i;
                                var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{inverseDepth}").AddClass(TotalClass, isTotal).Build();
                                <th class="@calcClass tmpx @i @RowRender.MaxDepth" colspan="@leafCount" rowspan="@rowSpan">@cell.Title</th>
                            }
                        </tr>
                    }
                    @if (!IsVertical)
                    {
                        <tr class="@_headRowClassname">
                            @if (RenderHeaderTitles)
                            {
                                @for (int i = 0; i < ColRender.MaxDepth; i++)
                                {
                                    var inverseDepth = ColRender.MaxDepth - i;
                                    <th class="@_rowTitleClass dpth-@inverseDepth tmph">@ColRender.HeaderTitle(i)</th>
                                }
                            }
                            @foreach (var cell in RowRender.Leaves)
                            {
                                @foreach (var measure in _pivot.Measures)
                                {
                                    /*Component RenderMeasureTitleCell */
                                    <th class="@_measureTitleClass dpth-1">@measure.Title</th>
                                }
                            }
                        </tr>
                    }
                </thead>

            }
            @*Render Rows*@
            <tbody class="mud-table-body">
                @foreach (var leaf in ColRender.Leaves)
                {
                    var path = leaf.Path;
                    var newLeaf = path.LastOrDefault(p => !p.IsFirstChild);
                        //var lastLeaf = path.FirstOrDefault(p => !p.IsLastChild);
                        bool levelFound = (newLeaf == null);
                        //var rowClass = new CssBuilder(RowClass).AddClass(RowClassFunc?.Invoke(leaf)).AddClass(RowCssClass).Build();
                        //var rowStyle = new StyleBuilder().AddStyle(RowStyle).AddStyle(RowStyleFunc?.Invoke(leaf)).Build();
                        //var isRowTotal = lastLeaf is PivotTableTotalColumnRender<T>;
                        // isRowTotal = false;
                        int inverseColDepth = 0;                       
                        //var isT = leaf.Children == null ? true : false;
                        

                        

                        @if (IsVertical)
                        {
                            <tr class="@_rowClass tmpa" @key="leaf">
                                @foreach (var cell in path)
                                {
                                    if (!levelFound && cell != newLeaf)
                                        continue;
                                    levelFound = true;
                                    //isRowTotal = false;

                                    var rowSpan = cell.Leaf.Count() * VerticalMeasureRatio;
                                    var isTotal = (cell is PivotTableTotalColumnRender<T>);
                                    int depth = isTotal ? cell.depth - 1 : cell.depth;
                                    var colSpan = (isTotal ? ColRender.MaxDepth - cell.depth : 1);
                                    inverseColDepth = ColRender.MaxDepth - depth;
                                   // @if (colSpan > 0)
                                    //{
                                        //isRowTotal = true;
                                    //}
                                    @if (isTotal && ColRender.MaxDepth == cell.depth)

                                    { }
                                    else
                                    {

                                        var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{inverseColDepth}").AddClass(TotalClass, isTotal).Build();
                                        <th class="@calcClass" colspan="@colSpan" rowspan="@rowSpan">@cell.Title</th>
                                    }
                                }
                                @{
                                    var firstMeasure = _pivot.Measures.First();
                                    var calcClassM = new CssBuilder(_measureTitleClass).AddClass($"dpth-{inverseColDepth - 1}")/*.AddClass(TotalClass, isTotal)*/.Build();

                                }

                                <th class="@calcClassM tmp1">@firstMeasure.Title</th>

                                @foreach (var colHeaderCell in RowRender.Leaves)
                                {
                                    //Console.WriteLine(isRowTotal);
                                    var inverseRowDepth = RowRender.MaxDepth - colHeaderCell.RenderDepth;
                                    //var totalDepth = (inverseDepth + inverseRowDepth);
                                    var totalDepth = (inverseColDepth + inverseRowDepth); // isRowTotal ? inverseDepth + inverseRowDepth : inverseRowDepth;

                                    /*bool? showTotals = colHeaderCell.Cell?.Column?.Options?.ShowTotalsForSingleValues;
                                    if (showTotals == false)
                                        totalDepth--;*/

                                    var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{totalDepth}").AddClass(TotalClass, totalDepth > 0).Build();
                                    <td class="@calcClass tmpka @RowRender.MaxDepth @colHeaderCell.depth @inverseColDepth">@_pivot[leaf.Cell, colHeaderCell.Cell, firstMeasure].ToString(firstMeasure.Format)</td>
                                }
                            </tr>
                            bool first = true;
                            @foreach (var measure in _pivot.Measures)
                            {         
                            if (first)
                            {
                                first = false;
                                continue;
                            }
                            <tr class="@_rowClass tmpgx">
                                @*Component RenderMeasureTitleCell *@
                                    @{
                                        var calcClassMX = new CssBuilder(_measureTitleClass).AddClass($"dpth-{inverseColDepth - 1}")/*.AddClass(TotalClass, isTotal)*/.Build();
                                    }
                                    <th class="@calcClassMX tmp1">@measure.Title</th>

                                @foreach (var colHeaderCell in RowRender.Leaves)
                                {
                                    //Console.WriteLine(isRowTotal);
                                        var inverseRowDepth = RowRender.MaxDepth - colHeaderCell.RenderDepth;
                                        //var totalDepth = (inverseDepth + inverseRowDepth);
                                    var totalDepth = (inverseColDepth + inverseRowDepth); // isRowTotal ? inverseDepth + inverseRowDepth : inverseRowDepth;

                                        /*bool? showTotals = colHeaderCell.Cell?.Column?.Options?.ShowTotalsForSingleValues;
                                        if (showTotals == false)
                                            totalDepth--;*/

                                        var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{totalDepth}").AddClass(TotalClass, totalDepth > 0).Build();
                                        <td class="@calcClass tmpkb @RowRender.MaxDepth @colHeaderCell.depth @inverseColDepth">@_pivot[leaf.Cell, colHeaderCell.Cell, measure].ToString(measure.Format)</td>
                                }
                            </tr>
                            }

                        }
                        else
                        {
                            bool isRowTotal = false;
                            //int colDepth = 0; 
                            var colLeafs = leaf.Leaf.Count();
                            var colPaths = leaf.Path.Count();

                            <tr class="@_rowClass tmpa" @key="leaf">
                            @foreach (var cell in path)
                                {
                                    if (!levelFound && cell != newLeaf)
                                    continue;
                                levelFound = true;
                                
                                var rowSpan = cell.Leaf.Count() * VerticalMeasureRatio;
                                bool isTotal = (cell is PivotTableTotalColumnRender<T>);
                                    int depth = isTotal ? cell.depth - 1 : cell.depth;
                                    var colSpan = (isTotal ? ColRender.MaxDepth - cell.depth : 1);
                                    inverseColDepth = (ColRender.MaxDepth - cell.depth);
                                @if (colSpan > 0)
                                {
                                        var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{inverseColDepth}").AddClass(TotalClass, isTotal).Build();
                                    <th class="@calcClass" colspan="@colSpan" rowspan="@rowSpan">@cell.Title</th>
                                    isRowTotal = true;
                                }
                            }

                            @foreach (var colHeaderCell in RowRender.Leaves)
                            {
                                foreach (var measure in _pivot.Measures)

                                {
                                        var leafs = colHeaderCell.Leaf.Count();

                            var paths = colHeaderCell.Path.Count();
                                        var isColTotal = (colHeaderCell is PivotTableTotalColumnRender<T>);
                                        var isLeafTotal = (leaf is PivotTableTotalColumnRender<T>);
                                            
                                        //colHeaderCell.Cell.
                                    //colHeaderCell.IsFirstChild
                                    //colHeaderCell.depth;
                                        var lastChild = colHeaderCell.IsLastChild;
                                        var children = colHeaderCell.Children.Any();
                                        //ColRender.MaxDepth - cell.depth
                                        
                                        //var inverseRowDepth = (tmp == false) ? (RowRender.MaxDepth - colHeaderCell.depth) - 1 : RowRender.MaxDepth - colHeaderCell.depth;*/
                                        //var inverseRowDepth = (tmp == true && (isRowTotal2 || isColTotal)) ? RowRender.MaxDepth - colHeaderCell.depth : RowRender.MaxDepth - colHeaderCell.depth - 1;
                                        var inverseRowDepth = RowRender.MaxDepth - colHeaderCell.RenderDepth;

                                        var totalDepth = inverseColDepth;
                                        if (inverseRowDepth > 0)
                                            totalDepth++;
                                        /*working crosses 1 depth above
                                        if (!isColTotal)
                                        totalDepth--;
                                        if (isRowTotal)
                                        totalDepth++;
                                        */

                                        /*working crosses are the same colour*/
                                        //if (!isColTotal && !isRowTotal)
                                        //    totalDepth--;
                                        //if (isRowTotal)
                                        //    totalDepth++;

                                        //var totalDepth = (inverseDepth + inverseRowDepth);
                                       /* var totalDepth = (inverseColDepth + inverseRowDepth) - 1;
                                        if (isColTotal && !isRowTotal)
                                            totalDepth++;*/
                                        /* (isRowTotal || isColTotal)
                                            totalDepth*/
                                        /*bool? showTotals = colHeaderCell.Cell?.Column?.Options?.ShowTotalsForSingleValues;
                                        if (showTotals == false)
                                            totalDepth--;*/
                                        /* if (!isColTotal)
                                            totalDepth--;
                                        if (!isRowTotal2)
                                            totalDepth--;*/
                                        //: 0; // isRowTotal ? inverseDepth + inverseRowDepth : inverseRowDepth;
                                                                                               //var totalDepth = lastChild ? (inverseDepth + inverseRowDepth) - 1 : (inverseDepth + inverseRowDepth) - 2;

                                        //var d = colHeaderCell.depth;
                                    var calcClass = new CssBuilder(CellClass).AddClass($"dpth-{totalDepth}").AddClass(TotalClass, totalDepth > 0).Build();
                                        <td class="@calcClass @totalDepth tmpkc 
    RowRender.MaxDepth: @RowRender.MaxDepth
    ColRender.MaxDepth: @ColRender.MaxDepth
    colHeaderCell.depth:@colHeaderCell.depth 
    colHeaderCell.RenderDepth:@colHeaderCell.RenderDepth
    inverseColDepth:    @inverseColDepth 
    inverseRowDepth:    @inverseRowDepth 
    totalDepth:         @totalDepth 
    isRowTotal:         @isRowTotal
    isColTotal:         @isColTotal
    isLeafTotal:        @isLeafTotal
    lastChild:          @lastChild
    children:           @children
    leafs:              @leafs
    paths:              @paths
    colleafs:           @colLeafs
    colpaths:           @colPaths">
                                            @_pivot[leaf.Cell, colHeaderCell.Cell, measure].ToString(measure.Format)</td>
                                }
                            }

                            </tr>
                        }

                }
            </tbody>
        </table>
        </div>
    }
</div>